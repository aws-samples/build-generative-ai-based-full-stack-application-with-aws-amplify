AWSTemplateFormatVersion: '2010-09-09'
Description: 'Bedrock Agent with Action Group and Lambda Function for Course Search'

Parameters:
  AgentName:
    Type: String
    Default: 'CourseSearchAgent'
    Description: 'Name of the Bedrock Agent'
  
  ModelId:
    Type: String
    Default: 'us.amazon.nova-pro-v1:0'
    Description: 'Foundation model ID for the agent'
  
  DynamoDBTableName:
    Type: String
    Default: 'Class'
    Description: 'DynamoDB table name containing course data'

Resources:
  # IAM Role for Bedrock Agent
  BedrockAgentRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
      Policies:
        - PolicyName: !Sub '${AgentName}-BedrockAgentPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource: !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/${ModelId}'

  # IAM Role for Lambda Function
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
      Policies:
        - PolicyName: !Sub '${AgentName}-DynamoDBReadPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:GetItem
                Resource: !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/*'

  # Lambda Function for Course Search
  CourseSearchFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AgentName}-CourseSearch'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          DYNAMODB_TABLE_NAME: !Ref DynamoDBTableName
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from boto3.dynamodb.conditions import Attr

          def lambda_handler(event, context):
              """
              Semantic video search using Bedrock
              """
              
              print(f"üì• Received event: {json.dumps(event, default=str)}")
              
              try:
                  api_path = event.get('apiPath', '')
                  http_method = event.get('httpMethod', '')
                  request_body = event.get('requestBody', {})
                  
                  print(f"üîç API Path: {api_path}, Method: {http_method}")
                  
                  dynamodb = boto3.resource('dynamodb', region_name='us-west-2')
                  bedrock = boto3.client('bedrock-runtime', region_name='us-west-2')
                  
                  if api_path == '/search_classes' and http_method == 'POST':
                      content = request_body.get('content', {})
                      app_json = content.get('application/json', {})
                      properties = app_json.get('properties', [])
                      
                      query = ''
                      for prop in properties:
                          if prop.get('name') == 'query':
                              query = prop.get('value', '')
                              break
                      
                      print(f"üîé User query: {query}")
                      result = search_with_bedrock(dynamodb, bedrock, query)
                      
                  else:
                      result = {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'Unknown endpoint'})
                      }
                  
                  response = {
                      'messageVersion': '1.0',
                      'response': {
                          'actionGroup': event.get('actionGroup', 'ClassSearchActions'),
                          'apiPath': api_path,
                          'httpMethod': http_method,
                          'httpStatusCode': result.get('statusCode', 200),
                          'responseBody': {
                              'application/json': {
                                  'body': result.get('body', '{}')
                              }
                          }
                      }
                  }
                  
                  print(f"üì§ Return response: {json.dumps(response, ensure_ascii=False, default=str)}")
                  return response
                  
              except Exception as e:
                  print(f"‚ùå Error occurred: {str(e)}")
                  import traceback
                  print(f"üìã Stack trace: {traceback.format_exc()}")
                  
                  return {
                      'messageVersion': '1.0',
                      'response': {
                          'actionGroup': event.get('actionGroup', ''),
                          'apiPath': event.get('apiPath', ''),
                          'httpMethod': event.get('httpMethod', ''),
                          'httpStatusCode': 500,
                          'responseBody': {
                              'application/json': {
                                  'body': {'error': str(e)}
                              }
                          }
                      }
                  }

          def search_with_bedrock(dynamodb, bedrock, query):
              """Understand question with Bedrock Nova Pro and search DynamoDB"""
              
              table_name = os.environ['DYNAMODB_TABLE_NAME']
              
              try:
                  # 1. Get all active courses from DynamoDB
                  table = dynamodb.Table(table_name)
                  response = table.scan(
                      FilterExpression=Attr('class_flag').ne(10) & (Attr('class_flag').eq(0) | Attr('class_flag').not_exists())
                  )
                  
                  all_courses = response.get('Items', [])
                  print(f"üìä Total courses: {len(all_courses)}")
                  
                  if not all_courses:
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'courses_found': 0,
                              'courses': [],
                              'message': 'No courses registered.'
                          }, ensure_ascii=False)
                      }
                  
                  # 2. Convert course list to text (max 50)
                  courses_text = "\n\n".join([
                      f"Course {i+1}:\nTitle: {c.get('name', '')}\nDescription: {c.get('description', '')}\nDifficulty: {c.get('difficulty', 'intermediate')}"
                      for i, c in enumerate(all_courses[:50])
                  ])
                  
                  # 3. Bedrock Nova Pro prompt
                  prompt = f"""User question: {query}

          Here is the list of available AWS courses:

          {courses_text}

          Select up to 3 courses that best match the user's question from the above list, and return only the course numbers as a JSON array.
          Example: {{"selected": [1, 3, 5]}}

          If no suitable courses are found, return an empty array: {{"selected": []}}

          Return only JSON without any other explanation."""

                  # 4. Call Bedrock Nova Pro
                  body = json.dumps({
                      "messages": [
                          {
                              "role": "user",
                              "content": [{"text": prompt}]
                          }
                      ],
                      "inferenceConfig": {
                          "max_new_tokens": 500,
                          "temperature": 0.3
                      }
                  })
                  
                  bedrock_response = bedrock.invoke_model(
                      modelId='us.amazon.nova-pro-v1:0',
                      body=body
                  )
                  
                  response_body = json.loads(bedrock_response['body'].read())
                  bedrock_text = response_body['output']['message']['content'][0]['text']
                  print(f"ü§ñ Bedrock response: {bedrock_text}")
                  
                  # 5. Extract JSON
                  selected_indices = json.loads(bedrock_text)['selected']
                  
                  # 6. Build selected course information
                  selected_courses = []
                  for idx in selected_indices:
                      if 0 < idx <= len(all_courses):
                          course = all_courses[idx - 1]
                          selected_courses.append({
                              'title': str(course.get('name', '')),
                              'description': str(course.get('description', ''))[:150] + '...' if len(str(course.get('description', ''))) > 150 else str(course.get('description', '')),
                              'url': str(course.get('url', '')),
                              'thumbnail': str(course.get('image', '')),
                              'author': str(course.get('author', '')),
                              'difficulty': str(course.get('difficulty', 'intermediate'))
                          })
                  
                  message = f"Found {len(selected_courses)} courses related to '{query}'." if selected_courses else f"No courses found related to '{query}'."
                  
                  result_data = {
                      'courses_found': len(selected_courses),
                      'courses': selected_courses,
                      'message': message,
                      'traces': [
                          {'type': 'preprocessing', 'content': f"üîç Started searching for '{query}'", 'timestamp': ''},
                          {'type': 'function_call', 'content': f'‚ö° Analyzing {len(all_courses)} courses with Bedrock Nova Pro', 'timestamp': ''},
                          {'type': 'observation', 'content': f'‚úÖ Completed selection of {len(selected_courses)} courses', 'timestamp': ''}
                      ]
                  }
                  
                  print(f"‚úÖ Search completed: {len(selected_courses)} courses found")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(result_data, ensure_ascii=False)
                  }
                  
              except Exception as e:
                  print(f"‚ùå Search Error: {str(e)}")
                  import traceback
                  print(traceback.format_exc())
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': f'Search error: {str(e)}'})
                  }



  # Lambda Permission for Bedrock Agent
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CourseSearchFunction
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*'

  # Bedrock Agent
  BedrockAgent:
    Type: AWS::Bedrock::Agent
    Properties:
      AgentName: !Ref AgentName
      Description: 'AI Agent for searching and recommending AWS courses'
      FoundationModel: !Ref ModelId
      AgentResourceRoleArn: !GetAtt BedrockAgentRole.Arn
      Instruction: |
        You are an AWS course search expert. Always return with languages that user provides.
        You should reply with the language of the written query.
        User question ‚Üí call search_classes ‚Üí recommend max 3 courses
        Response format (JSON only):
        JSON FORMAT (copy exact values):
        {
          "title": "Title",
          "sections": [
            {
              "type": "course",
              "title": "<copy from courses[].title and translate to  with user's given language>",
              "difficulty": "<copy from courses[].difficulty and translate to  with user's given language>",
              "instructor": "<copy from courses[].author>",
              "description": "<copy from courses[].description and translate to  with user's given language>",
              "link": "<copy from courses[].url>",
              "thumbnail": "<copy from courses[].thumbnail>",
              "reason": "<your 1 sentence with user's given language>"
            }
          ]
        }
        - No header or text sections
        - Max 3 courses only
        - Each field limited to 1 sentence
        - Complete within 20 seconds
      ActionGroups:
        - ActionGroupName: 'CourseSearchActionGroup'
          Description: 'Search for courses in DynamoDB'
          ActionGroupExecutor:
            Lambda: !GetAtt CourseSearchFunction.Arn
          ApiSchema:
            Payload: |
              {
                "openapi": "3.0.0",
                "info": {
                  "title": "Course Search API",
                  "version": "1.0.0",
                  "description": "API for searching courses in DynamoDB"
                },
                "paths": {
                  "/search_classes": {
                    "post": {
                      "summary": "Search for classes/courses",
                      "description": "Search for classes or courses based on query parameters",
                      "operationId": "search_classes",
                      "requestBody": {
                        "required": true,
                        "content": {
                          "application/json": {
                            "schema": {
                              "type": "object",
                              "properties": {
                                "query": {
                                  "type": "string",
                                  "description": "Search query for finding relevant courses"
                                }
                              },
                              "required": ["query"]
                            }
                          }
                        }
                      },
                      "responses": {
                        "200": {
                          "description": "Successful response",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "courses_found": {
                                    "type": "integer"
                                  },
                                  "courses": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "title": {"type": "string"},
                                        "description": {"type": "string"},
                                        "url": {"type": "string"},
                                        "author": {"type": "string"},
                                        "difficulty": {"type": "string"}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

  # Bedrock Agent Alias
  BedrockAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    Properties:
      AgentId: !Ref BedrockAgent
      AgentAliasName: 'DRAFT'
      Description: 'Draft alias for the course search agent'

Outputs:
  AgentId:
    Description: 'Bedrock Agent ID'
    Value: !Ref BedrockAgent
    Export:
      Name: !Sub '${AWS::StackName}-AgentId'
  
  AgentAliasId:
    Description: 'Bedrock Agent Alias ID'
    Value: !GetAtt BedrockAgentAlias.AgentAliasId
    Export:
      Name: !Sub '${AWS::StackName}-AgentAliasId'
  
  LambdaFunctionArn:
    Description: 'Lambda Function ARN'
    Value: !GetAtt CourseSearchFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-LambdaArn'
  
  AgentArn:
    Description: 'Bedrock Agent ARN'
    Value: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${BedrockAgent}'
    Export:
      Name: !Sub '${AWS::StackName}-AgentArn'

AWSTemplateFormatVersion: '2010-09-09'
Description: 'Bedrock Agent with Action Group and Lambda Function for Course Search'

Parameters:
  AgentName:
    Type: String
    Default: 'CourseSearchAgent'
    Description: 'Name of the Bedrock Agent'
  
  ModelId:
    Type: String
    Default: 'us.anthropic.claude-3-7-sonnet-20250219-v1:0'
    Description: 'Foundation model ID for the agent'
  
  DynamoDBTableName:
    Type: String
    Default: 'Class'
    Description: 'DynamoDB table name containing course data'

Resources:
  # IAM Role for Bedrock Agent
  BedrockAgentRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
      Policies:
        - PolicyName: !Sub '${AgentName}-BedrockAgentPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource: !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/${ModelId}'

  # IAM Role for Lambda Function
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub '${AgentName}-DynamoDBReadPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:GetItem
                Resource: !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/*'

  # Lambda Function for Course Search
  CourseSearchFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AgentName}-CourseSearch'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          DYNAMODB_TABLE_NAME: !Ref DynamoDBTableName
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from boto3.dynamodb.conditions import Attr, Contains
          from decimal import Decimal

          def lambda_handler(event, context):
              """
              Bedrock Agent Action Groupì„ ìœ„í•œ Lambda í•¨ìˆ˜
              ì‚¬ìš©ì ì§ˆë¬¸ì— ê¸°ë°˜í•˜ì—¬ ê´€ë ¨ ì˜ìƒì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.
              """
              
              print(f"ğŸ“¥ ë°›ì€ ì´ë²¤íŠ¸: {json.dumps(event, default=str)}")
              
              try:
                  # Bedrock Agent ì´ë²¤íŠ¸ êµ¬ì¡° íŒŒì‹±
                  api_path = event.get('apiPath', '')
                  http_method = event.get('httpMethod', '')
                  request_body = event.get('requestBody', {})
                  
                  print(f"ğŸ” API Path: {api_path}, Method: {http_method}")
                  print(f"ğŸ“¦ Request Body: {request_body}")
                  
                  # DynamoDB í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
                  dynamodb = boto3.resource('dynamodb', region_name='us-east-1')
                  
                  if api_path == '/search_classes' and http_method == 'POST':
                      # requestBodyì—ì„œ content ì¶”ì¶œ
                      content = request_body.get('content', {})
                      app_json = content.get('application/json', {})
                      properties = app_json.get('properties', [])
                      
                      # propertiesì—ì„œ query íŒŒë¼ë¯¸í„° ì¶”ì¶œ
                      query = ''
                      for prop in properties:
                          if prop.get('name') == 'query':
                              query = prop.get('value', '')
                              break
                      
                      print(f"ğŸ” ì¶”ì¶œëœ query: {query}")
                      result = search_classes(dynamodb, query)
                      function_name = 'search_classes'
                  else:
                      result = {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'Unknown endpoint'})
                      }
                      function_name = 'unknown'
                  
                  # Bedrock Agent ì‘ë‹µ í˜•ì‹ (AWS ê³µì‹ ìŠ¤í™)
                  response = {
                      'messageVersion': '1.0',
                      'response': {
                          'actionGroup': event.get('actionGroup', 'ClassSearchActions'),
                          'apiPath': api_path,
                          'httpMethod': http_method,
                          'httpStatusCode': result.get('statusCode', 200),
                          'responseBody': {
                              'application/json': {
                                  'body': result.get('body', '{}')
                              }
                          }
                      }
                  }
                  
                  print(f"ğŸ“¤ ë°˜í™˜ ì‘ë‹µ: {json.dumps(response, ensure_ascii=False, default=str)}")
                  return response
                  
              except Exception as e:
                  print(f"âŒ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")
                  import traceback
                  print(f"ğŸ“‹ ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤: {traceback.format_exc()}")
                  
                  error_body = {'error': str(e)}
                  error_response = {
                      'messageVersion': '1.0',
                      'response': {
                          'actionGroup': event.get('actionGroup', ''),
                          'apiPath': event.get('apiPath', ''),
                          'httpMethod': event.get('httpMethod', ''),
                          'httpStatusCode': 500,
                          'responseBody': {
                              'application/json': {
                                  'body': error_body
                              }
                          }
                      }
                  }
                  
                  print(f"ğŸ“¤ ì—ëŸ¬ ì‘ë‹µ: {json.dumps(error_response, ensure_ascii=False, default=str)}")
                  return error_response

          def search_classes(dynamodb, query):
              """DynamoDBì—ì„œ ì˜ìƒ ê²€ìƒ‰ - description ê¸°ë°˜ ê°„ë‹¨ ê²€ìƒ‰"""
              
              print(f"ğŸ” ê²€ìƒ‰ ì¿¼ë¦¬: {query}")
              
              # ê²€ìƒ‰ì–´ë¥¼ ê°œë³„ í‚¤ì›Œë“œë¡œ ë¶„ë¦¬
              search_terms = [term.strip().lower() for term in query.split() if term.strip()] if query else []
              
              print(f"ğŸ” ê²€ìƒ‰ì–´: {search_terms}")
              
              table_name = os.environ['DYNAMODB_TABLE_NAME']
              
              try:
                  table = dynamodb.Table(table_name)
                  
                  # ê²€ìƒ‰ì–´ê°€ ì—†ìœ¼ë©´ ë¹ˆ ê²°ê³¼ ë°˜í™˜
                  if not search_terms:
                      print("âš ï¸ ê²€ìƒ‰ì–´ ì—†ìŒ - ë¹ˆ ê²°ê³¼ ë°˜í™˜")
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'courses_found': 0,
                              'courses': [],
                              'message': 'ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.'
                          }, ensure_ascii=False)
                      }
                  
                  # í™œì„± ì˜ìƒë§Œ ì¡°íšŒ
                  base_filter = Attr('class_flag').ne(10) & (Attr('class_flag').eq(0) | Attr('class_flag').not_exists())
                  
                  # nameê³¼ description í•„ë“œì—ì„œ ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—†ì´ ê²€ìƒ‰
                  search_conditions = []
                  for term in search_terms:
                      term_lower = term.lower()
                      term_upper = term.upper()
                      term_title = term.title()
                      
                      search_conditions.append(
                          Contains(Attr('name'), term) |
                          Contains(Attr('name'), term_lower) |
                          Contains(Attr('name'), term_upper) |
                          Contains(Attr('name'), term_title) |
                          Contains(Attr('description'), term) |
                          Contains(Attr('description'), term_lower) |
                          Contains(Attr('description'), term_upper) |
                          Contains(Attr('description'), term_title)
                      )
                  
                  # OR ì¡°ê±´ìœ¼ë¡œ ê²°í•©
                  search_filter = search_conditions[0]
                  for condition in search_conditions[1:]:
                      search_filter = search_filter | condition
                  
                  final_filter = base_filter & search_filter
                  
                  # ìŠ¤ìº” ì‹¤í–‰
                  response = table.scan(
                      FilterExpression=final_filter,
                      Limit=20
                  )
                  
                  print(f"ğŸ“Š ìŠ¤ìº” ê²°ê³¼: {len(response.get('Items', []))}ê°œ í•­ëª©")
                  
                  # ê²°ê³¼ í¬ë§·íŒ… - thumbnailê³¼ URLë§Œ í¬í•¨
                  classes = []
                  for item in response.get('Items', []):
                      class_info = {
                          'title': str(item.get('name', '')),
                          'description': str(item.get('description', ''))[:150] + '...' if len(str(item.get('description', ''))) > 150 else str(item.get('description', '')),
                          'url': str(item.get('url', '')),
                          'thumbnail': str(item.get('image', '')),
                          'author': str(item.get('author', '')),
                          'difficulty': str(item.get('difficulty', 'intermediate'))
                      }
                      classes.append(class_info)
                  
                  # ìƒìœ„ 5ê°œë§Œ ë°˜í™˜
                  top_classes = classes[:5]
                  
                  message = f"'{' '.join(search_terms)}' ê´€ë ¨ ê°•ì˜ {len(top_classes)}ê°œë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤." if top_classes else f"'{' '.join(search_terms)}' ê´€ë ¨ ê°•ì˜ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
                  
                  result_data = {
                      'courses_found': len(top_classes),
                      'courses': top_classes,
                      'message': message,
                      'traces': [
                          {'type': 'preprocessing', 'content': f"ğŸ” '{' '.join(search_terms)}' ê²€ìƒ‰ ì‹œì‘", 'timestamp': ''},
                          {'type': 'function_call', 'content': f'âš¡ DynamoDBì—ì„œ {len(classes)}ê°œ í•­ëª© ë°œê²¬', 'timestamp': ''},
                          {'type': 'observation', 'content': f'âœ… ìƒìœ„ {len(top_classes)}ê°œ ê°•ì˜ ì„ íƒ ì™„ë£Œ', 'timestamp': ''}
                      ]
                  }
                  
                  print(f"âœ… ê²€ìƒ‰ ì™„ë£Œ: {len(top_classes)}ê°œ ì˜ìƒ ë°œê²¬")
                  print(f"ğŸ“Š ê²°ê³¼ ë°ì´í„°: {json.dumps(result_data, ensure_ascii=False)}")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(result_data, ensure_ascii=False)
                  }
                  
              except Exception as e:
                  print(f"âŒ í…Œì´ë¸” ì ‘ê·¼ ì˜¤ë¥˜: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': f'Database error: {str(e)}'})
                  }


  # Lambda Permission for Bedrock Agent
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CourseSearchFunction
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*'

  # Bedrock Agent
  BedrockAgent:
    Type: AWS::Bedrock::Agent
    Properties:
      AgentName: !Ref AgentName
      Description: 'AI Agent for searching and recommending AWS courses'
      FoundationModel: !Ref ModelId
      AgentResourceRoleArn: !GetAtt BedrockAgentRole.Arn
      Instruction: |
        ë‹¹ì‹ ì€ AWS í•™ìŠµ ì˜ìƒ ê²€ìƒ‰ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

        You are an AWS course search expert.
        You should reply with the language of the written query.

        User question â†’ call search_classes â†’ recommend max 3 courses

        Response format (JSON only):
        JSON FORMAT (copy exact values):
        {
          "title": "Title",
          "sections": [
            {
              "type": "course",
              "title": "<copy from courses[].title>",
              "difficulty": "<copy from courses[].difficulty>",
              "instructor": "<copy from courses[].author>",
              "description": "<copy from courses[].description>",
              "link": "<copy from courses[].url>",
              "thumbnail": "<copy from courses[].thumbnail>",
              "reason": "<your 1 sentence>"
            }
          ]
        }

        - No header or text sections
        - Max 3 courses only
        - Each field limited to 1 sentence
        - Complete within 20 seconds
      ActionGroups:
        - ActionGroupName: 'CourseSearchActionGroup'
          Description: 'Search for courses in DynamoDB'
          ActionGroupExecutor:
            Lambda: !GetAtt CourseSearchFunction.Arn
          ApiSchema:
            Payload: |
              {
                "openapi": "3.0.0",
                "info": {
                  "title": "Course Search API",
                  "version": "1.0.0",
                  "description": "API for searching courses in DynamoDB"
                },
                "paths": {
                  "/search_classes": {
                    "post": {
                      "summary": "Search for classes/courses",
                      "description": "Search for classes or courses based on query parameters",
                      "operationId": "search_classes",
                      "requestBody": {
                        "required": true,
                        "content": {
                          "application/json": {
                            "schema": {
                              "type": "object",
                              "properties": {
                                "query": {
                                  "type": "string",
                                  "description": "Search query for finding relevant courses"
                                }
                              },
                              "required": ["query"]
                            }
                          }
                        }
                      },
                      "responses": {
                        "200": {
                          "description": "Successful response",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "courses_found": {
                                    "type": "integer"
                                  },
                                  "courses": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "title": {"type": "string"},
                                        "description": {"type": "string"},
                                        "url": {"type": "string"},
                                        "author": {"type": "string"},
                                        "difficulty": {"type": "string"}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

  # Bedrock Agent Alias
  BedrockAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    Properties:
      AgentId: !Ref BedrockAgent
      AgentAliasName: 'DRAFT'
      Description: 'Draft alias for the course search agent'

Outputs:
  AgentId:
    Description: 'Bedrock Agent ID'
    Value: !Ref BedrockAgent
    Export:
      Name: !Sub '${AWS::StackName}-AgentId'
  
  AgentAliasId:
    Description: 'Bedrock Agent Alias ID'
    Value: !GetAtt BedrockAgentAlias.AgentAliasId
    Export:
      Name: !Sub '${AWS::StackName}-AgentAliasId'
  
  LambdaFunctionArn:
    Description: 'Lambda Function ARN'
    Value: !GetAtt CourseSearchFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-LambdaArn'
  
  AgentArn:
    Description: 'Bedrock Agent ARN'
    Value: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${BedrockAgent}'
    Export:
      Name: !Sub '${AWS::StackName}-AgentArn'

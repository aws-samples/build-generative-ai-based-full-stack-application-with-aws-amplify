AWSTemplateFormatVersion: '2010-09-09'
Description: 'Bedrock Agent with Action Group and Lambda Function for Course Search'

Parameters:
  AgentName:
    Type: String
    Default: 'CourseSearchAgent'
    Description: 'Name of the Bedrock Agent'
  
  ModelId:
    Type: String
    Default: 'us.amazon.nova-pro-v1:0'
    Description: 'Foundation model ID for the agent'
  
  DynamoDBTableName:
    Type: String
    Default: 'Class'
    Description: 'DynamoDB table name containing course data'

Resources:
  # IAM Role for Bedrock Agent
  BedrockAgentRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
      Policies:
        - PolicyName: !Sub '${AgentName}-BedrockAgentPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource: !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/${ModelId}'

  # IAM Role for Lambda Function
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
      Policies:
        - PolicyName: !Sub '${AgentName}-DynamoDBReadPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:GetItem
                Resource: !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/*'

  # Lambda Function for Course Search
  CourseSearchFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AgentName}-CourseSearch'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          DYNAMODB_TABLE_NAME: !Ref DynamoDBTableName
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from boto3.dynamodb.conditions import Attr

          def lambda_handler(event, context):
              """
              Bedrockì„ í™œìš©í•œ ì˜ë¯¸ ê¸°ë°˜ ì˜ìƒ ê²€ìƒ‰
              """
              
              print(f"ğŸ“¥ ë°›ì€ ì´ë²¤íŠ¸: {json.dumps(event, default=str)}")
              
              try:
                  api_path = event.get('apiPath', '')
                  http_method = event.get('httpMethod', '')
                  request_body = event.get('requestBody', {})
                  
                  print(f"ğŸ” API Path: {api_path}, Method: {http_method}")
                  
                  dynamodb = boto3.resource('dynamodb', region_name='us-west-2')
                  bedrock = boto3.client('bedrock-runtime', region_name='us-west-2')
                  
                  if api_path == '/search_classes' and http_method == 'POST':
                      content = request_body.get('content', {})
                      app_json = content.get('application/json', {})
                      properties = app_json.get('properties', [])
                      
                      query = ''
                      for prop in properties:
                          if prop.get('name') == 'query':
                              query = prop.get('value', '')
                              break
                      
                      print(f"ğŸ” ì‚¬ìš©ì ì§ˆë¬¸: {query}")
                      result = search_with_bedrock(dynamodb, bedrock, query)
                      
                  else:
                      result = {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'Unknown endpoint'})
                      }
                  
                  response = {
                      'messageVersion': '1.0',
                      'response': {
                          'actionGroup': event.get('actionGroup', 'ClassSearchActions'),
                          'apiPath': api_path,
                          'httpMethod': http_method,
                          'httpStatusCode': result.get('statusCode', 200),
                          'responseBody': {
                              'application/json': {
                                  'body': result.get('body', '{}')
                              }
                          }
                      }
                  }
                  
                  print(f"ğŸ“¤ ë°˜í™˜ ì‘ë‹µ: {json.dumps(response, ensure_ascii=False, default=str)}")
                  return response
                  
              except Exception as e:
                  print(f"âŒ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")
                  import traceback
                  print(f"ğŸ“‹ ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤: {traceback.format_exc()}")
                  
                  return {
                      'messageVersion': '1.0',
                      'response': {
                          'actionGroup': event.get('actionGroup', ''),
                          'apiPath': event.get('apiPath', ''),
                          'httpMethod': event.get('httpMethod', ''),
                          'httpStatusCode': 500,
                          'responseBody': {
                              'application/json': {
                                  'body': {'error': str(e)}
                              }
                          }
                      }
                  }

          def search_with_bedrock(dynamodb, bedrock, query):
              """Bedrock Nova Proë¡œ ì§ˆë¬¸ ì´í•´ í›„ DynamoDB ê²€ìƒ‰"""
              
              table_name = os.environ['DYNAMODB_TABLE_NAME']
              
              try:
                  # 1. DynamoDBì—ì„œ ëª¨ë“  í™œì„± ê°•ì˜ ê°€ì ¸ì˜¤ê¸°
                  table = dynamodb.Table(table_name)
                  response = table.scan(
                      FilterExpression=Attr('class_flag').ne(10) & (Attr('class_flag').eq(0) | Attr('class_flag').not_exists())
                  )
                  
                  all_courses = response.get('Items', [])
                  print(f"ğŸ“Š ì „ì²´ ê°•ì˜ ìˆ˜: {len(all_courses)}ê°œ")
                  
                  if not all_courses:
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'courses_found': 0,
                              'courses': [],
                              'message': 'ë“±ë¡ëœ ê°•ì˜ê°€ ì—†ìŠµë‹ˆë‹¤.'
                          }, ensure_ascii=False)
                      }
                  
                  # 2. ê°•ì˜ ëª©ë¡ì„ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜ (ìµœëŒ€ 50ê°œ)
                  courses_text = "\n\n".join([
                      f"ê°•ì˜ {i+1}:\nì œëª©: {c.get('name', '')}\nì„¤ëª…: {c.get('description', '')}\në‚œì´ë„: {c.get('difficulty', 'intermediate')}"
                      for i, c in enumerate(all_courses[:50])
                  ])
                  
                  # 3. Bedrock Nova Pro í”„ë¡¬í”„íŠ¸
                  prompt = f"""ì‚¬ìš©ì ì§ˆë¬¸: {query}

          ë‹¤ìŒì€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” AWS ê°•ì˜ ëª©ë¡ì…ë‹ˆë‹¤:

          {courses_text}

          ìœ„ ê°•ì˜ ì¤‘ì—ì„œ ì‚¬ìš©ì ì§ˆë¬¸ì— ê°€ì¥ ì í•©í•œ ê°•ì˜ë¥¼ ìµœëŒ€ 3ê°œ ì„ íƒí•˜ê³ , ê° ê°•ì˜ ë²ˆí˜¸ë§Œ JSON ë°°ì—´ë¡œ ë°˜í™˜í•˜ì„¸ìš”.
          ì˜ˆì‹œ: {{"selected": [1, 3, 5]}}

          ë§Œì•½ ì í•©í•œ ê°•ì˜ê°€ ì—†ë‹¤ë©´ ë¹ˆ ë°°ì—´ì„ ë°˜í™˜í•˜ì„¸ìš”: {{"selected": []}}

          JSONë§Œ ë°˜í™˜í•˜ê³  ë‹¤ë¥¸ ì„¤ëª…ì€ í•˜ì§€ ë§ˆì„¸ìš”."""

                  # 4. Bedrock Nova Pro í˜¸ì¶œ
                  body = json.dumps({
                      "messages": [
                          {
                              "role": "user",
                              "content": [{"text": prompt}]
                          }
                      ],
                      "inferenceConfig": {
                          "max_new_tokens": 500,
                          "temperature": 0.3
                      }
                  })
                  
                  bedrock_response = bedrock.invoke_model(
                      modelId='us.amazon.nova-pro-v1:0',
                      body=body
                  )
                  
                  response_body = json.loads(bedrock_response['body'].read())
                  bedrock_text = response_body['output']['message']['content'][0]['text']
                  print(f"ğŸ¤– Bedrock ì‘ë‹µ: {bedrock_text}")
                  
                  # 5. JSON ì¶”ì¶œ
                  selected_indices = json.loads(bedrock_text)['selected']
                  
                  # 6. ì„ íƒëœ ê°•ì˜ ì •ë³´ êµ¬ì„±
                  selected_courses = []
                  for idx in selected_indices:
                      if 0 < idx <= len(all_courses):
                          course = all_courses[idx - 1]
                          selected_courses.append({
                              'title': str(course.get('name', '')),
                              'description': str(course.get('description', ''))[:150] + '...' if len(str(course.get('description', ''))) > 150 else str(course.get('description', '')),
                              'url': str(course.get('url', '')),
                              'thumbnail': str(course.get('image', '')),
                              'author': str(course.get('author', '')),
                              'difficulty': str(course.get('difficulty', 'intermediate'))
                          })
                  
                  message = f"'{query}' ê´€ë ¨ ê°•ì˜ {len(selected_courses)}ê°œë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤." if selected_courses else f"'{query}' ê´€ë ¨ ê°•ì˜ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
                  
                  result_data = {
                      'courses_found': len(selected_courses),
                      'courses': selected_courses,
                      'message': message,
                      'traces': [
                          {'type': 'preprocessing', 'content': f"ğŸ” '{query}' ê²€ìƒ‰ ì‹œì‘", 'timestamp': ''},
                          {'type': 'function_call', 'content': f'âš¡ Bedrock Nova Proë¡œ {len(all_courses)}ê°œ ê°•ì˜ ë¶„ì„', 'timestamp': ''},
                          {'type': 'observation', 'content': f'âœ… {len(selected_courses)}ê°œ ê°•ì˜ ì„ íƒ ì™„ë£Œ', 'timestamp': ''}
                      ]
                  }
                  
                  print(f"âœ… ê²€ìƒ‰ ì™„ë£Œ: {len(selected_courses)}ê°œ ê°•ì˜ ë°œê²¬")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(result_data, ensure_ascii=False)
                  }
                  
              except Exception as e:
                  print(f"âŒ ê²€ìƒ‰ ì˜¤ë¥˜: {str(e)}")
                  import traceback
                  print(traceback.format_exc())
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': f'Search error: {str(e)}'})
                  }



  # Lambda Permission for Bedrock Agent
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CourseSearchFunction
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*'

  # Bedrock Agent
  BedrockAgent:
    Type: AWS::Bedrock::Agent
    Properties:
      AgentName: !Ref AgentName
      Description: 'AI Agent for searching and recommending AWS courses'
      FoundationModel: !Ref ModelId
      AgentResourceRoleArn: !GetAtt BedrockAgentRole.Arn
      Instruction: |
        You are an AWS course search expert. Always return with languages that user provides.
        You should reply with the language of the written query.
        User question â†’ call search_classes â†’ recommend max 3 courses
        Response format (JSON only):
        JSON FORMAT (copy exact values):
        {
          "title": "Title",
          "sections": [
            {
              "type": "course",
              "title": "<copy from courses[].title>",
              "difficulty": "<copy from courses[].difficulty>",
              "instructor": "<copy from courses[].author>",
              "description": "<copy from courses[].description>",
              "link": "<copy from courses[].url>",
              "thumbnail": "<copy from courses[].thumbnail>",
              "reason": "<your 1 sentence with user's given language>"
            }
          ]
        }
        - No header or text sections
        - Max 3 courses only
        - Each field limited to 1 sentence
        - Complete within 20 seconds
      ActionGroups:
        - ActionGroupName: 'CourseSearchActionGroup'
          Description: 'Search for courses in DynamoDB'
          ActionGroupExecutor:
            Lambda: !GetAtt CourseSearchFunction.Arn
          ApiSchema:
            Payload: |
              {
                "openapi": "3.0.0",
                "info": {
                  "title": "Course Search API",
                  "version": "1.0.0",
                  "description": "API for searching courses in DynamoDB"
                },
                "paths": {
                  "/search_classes": {
                    "post": {
                      "summary": "Search for classes/courses",
                      "description": "Search for classes or courses based on query parameters",
                      "operationId": "search_classes",
                      "requestBody": {
                        "required": true,
                        "content": {
                          "application/json": {
                            "schema": {
                              "type": "object",
                              "properties": {
                                "query": {
                                  "type": "string",
                                  "description": "Search query for finding relevant courses"
                                }
                              },
                              "required": ["query"]
                            }
                          }
                        }
                      },
                      "responses": {
                        "200": {
                          "description": "Successful response",
                          "content": {
                            "application/json": {
                              "schema": {
                                "type": "object",
                                "properties": {
                                  "courses_found": {
                                    "type": "integer"
                                  },
                                  "courses": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "title": {"type": "string"},
                                        "description": {"type": "string"},
                                        "url": {"type": "string"},
                                        "author": {"type": "string"},
                                        "difficulty": {"type": "string"}
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

  # Bedrock Agent Alias
  BedrockAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    Properties:
      AgentId: !Ref BedrockAgent
      AgentAliasName: 'DRAFT'
      Description: 'Draft alias for the course search agent'

Outputs:
  AgentId:
    Description: 'Bedrock Agent ID'
    Value: !Ref BedrockAgent
    Export:
      Name: !Sub '${AWS::StackName}-AgentId'
  
  AgentAliasId:
    Description: 'Bedrock Agent Alias ID'
    Value: !GetAtt BedrockAgentAlias.AgentAliasId
    Export:
      Name: !Sub '${AWS::StackName}-AgentAliasId'
  
  LambdaFunctionArn:
    Description: 'Lambda Function ARN'
    Value: !GetAtt CourseSearchFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-LambdaArn'
  
  AgentArn:
    Description: 'Bedrock Agent ARN'
    Value: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${BedrockAgent}'
    Export:
      Name: !Sub '${AWS::StackName}-AgentArn'
